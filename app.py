#!/usr/bin/env python3
"""
Self-bootstrapping HTTP server exposed via UPnP IGD port mapping.

What it does:
- Discovers your router's UPnP IGD (if available)
- Creates a temporary TCP port mapping (external_port -> local_port)
- Retrieves and prints your public IP + external port + tokenized URL
- Runs an HTTP server that logs incoming requests to the console
- Removes the port mapping on exit (best-effort)

Requirements:
- Python 3 standard library only
- Router must support UPnP IGD and allow port mapping from your LAN
- Will NOT work behind CGNAT / strict corporate firewalls / UPnP disabled routers

Security:
- Requires a token (generated by default) via ?token=... or X-Auth-Token header
"""

import argparse
import atexit
import datetime as _dt
import os
import random
import socket
import sys
import threading
import time
import urllib.parse
import urllib.request
import xml.etree.ElementTree as ET
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer

SSDP_ADDR = ("239.255.255.250", 1900)
SSDP_ST = "urn:schemas-upnp-org:device:InternetGatewayDevice:1"
USER_AGENT = "python-upnp-bootstrap/1.0"


def now():
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def get_local_ip():
    # Pick the outbound interface IP without actually sending traffic.
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("1.1.1.1", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        # Fallback
        return socket.gethostbyname(socket.gethostname())


def ssdp_discover(timeout=3.0):
    """
    Send SSDP M-SEARCH to locate IGD device description URL (LOCATION header).
    Returns location URL string or None.
    """
    msg = "\r\n".join([
        "M-SEARCH * HTTP/1.1",
        f"HOST: {SSDP_ADDR[0]}:{SSDP_ADDR[1]}",
        'MAN: "ssdp:discover"',
        "MX: 2",
        f"ST: {SSDP_ST}",
        f"USER-AGENT: {USER_AGENT}",
        "",
        "",
    ]).encode("utf-8")

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.settimeout(timeout)
    try:
        sock.sendto(msg, SSDP_ADDR)
        # Listen for responses; pick the first LOCATION we see.
        end = time.time() + timeout
        while time.time() < end:
            data, _ = sock.recvfrom(65535)
            text = data.decode("utf-8", errors="ignore")
            headers = {}
            for line in text.split("\r\n")[1:]:
                if ":" in line:
                    k, v = line.split(":", 1)
                    headers[k.strip().lower()] = v.strip()
            loc = headers.get("location")
            if loc:
                return loc
    except socket.timeout:
        return None
    finally:
        sock.close()
    return None


def http_get(url, timeout=5.0):
    req = urllib.request.Request(url, headers={"User-Agent": USER_AGENT})
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return resp.read()


def find_igd_control_url(device_desc_url):
    """
    Fetch device description XML and find WANIPConnection / WANPPPConnection control URL + service type.
    Returns (control_url, service_type) or (None, None).
    """
    raw = http_get(device_desc_url)
    xml = ET.fromstring(raw)

    # Namespaces vary; strip them for simple searching.
    def strip_ns(tag):
        return tag.split("}", 1)[-1] if "}" in tag else tag

    base_url = device_desc_url
    # Some descriptions include <URLBase>
    urlbase = None
    for el in xml.iter():
        if strip_ns(el.tag) == "URLBase" and el.text:
            urlbase = el.text.strip()
            break
    if urlbase:
        base_url = urlbase

    # Search for the desired services in the serviceList
    service_candidates = [
        "urn:schemas-upnp-org:service:WANIPConnection:2",
        "urn:schemas-upnp-org:service:WANIPConnection:1",
        "urn:schemas-upnp-org:service:WANPPPConnection:1",
    ]

    # Iterate services
    for service in xml.iter():
        if strip_ns(service.tag) != "service":
            continue
        service_type = None
        control_url = None
        for child in list(service):
            name = strip_ns(child.tag)
            if name == "serviceType" and child.text:
                service_type = child.text.strip()
            elif name == "controlURL" and child.text:
                control_url = child.text.strip()
        if service_type in service_candidates and control_url:
            full_control = urllib.parse.urljoin(base_url, control_url)
            return full_control, service_type

    return None, None


def soap_call(control_url, service_type, action, body_xml, timeout=5.0):
    """
    Send a SOAP action to the IGD control URL.
    Returns response bytes.
    """
    envelope = f"""<?xml version="1.0"?>
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
            s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
  <s:Body>
    <u:{action} xmlns:u="{service_type}">
      {body_xml}
    </u:{action}>
  </s:Body>
</s:Envelope>
""".encode("utf-8")

    headers = {
        "Content-Type": 'text/xml; charset="utf-8"',
        "SOAPAction": f'"{service_type}#{action}"',
        "User-Agent": USER_AGENT,
    }
    req = urllib.request.Request(control_url, data=envelope, headers=headers, method="POST")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return resp.read()


def get_external_ip(control_url, service_type):
    resp = soap_call(control_url, service_type, "GetExternalIPAddress", "")
    xml = ET.fromstring(resp)
    # Find NewExternalIPAddress regardless of namespaces
    for el in xml.iter():
        if el.tag.endswith("NewExternalIPAddress") and el.text:
            return el.text.strip()
    return None


def add_port_mapping(control_url, service_type, external_port, internal_ip, internal_port, desc, lease_seconds=0):
    body = f"""
<NewRemoteHost></NewRemoteHost>
<NewExternalPort>{external_port}</NewExternalPort>
<NewProtocol>TCP</NewProtocol>
<NewInternalPort>{internal_port}</NewInternalPort>
<NewInternalClient>{internal_ip}</NewInternalClient>
<NewEnabled>1</NewEnabled>
<NewPortMappingDescription>{escape_xml(desc)}</NewPortMappingDescription>
<NewLeaseDuration>{lease_seconds}</NewLeaseDuration>
""".strip()
    soap_call(control_url, service_type, "AddPortMapping", body, timeout=8.0)


def delete_port_mapping(control_url, service_type, external_port):
    body = f"""
<NewRemoteHost></NewRemoteHost>
<NewExternalPort>{external_port}</NewExternalPort>
<NewProtocol>TCP</NewProtocol>
""".strip()
    soap_call(control_url, service_type, "DeletePortMapping", body, timeout=8.0)


def escape_xml(s):
    return (
        s.replace("&", "&amp;")
         .replace("<", "&lt;")
         .replace(">", "&gt;")
         .replace('"', "&quot;")
         .replace("'", "&apos;")
    )


class Handler(BaseHTTPRequestHandler):
    server_version = "UPnPBootstrapHTTP/1.0"

    def _authorized(self):
        token = self.server.token
        if not token:
            return True
        # Token via header or query string
        hdr = self.headers.get("X-Auth-Token")
        if hdr and hdr.strip() == token:
            return True
        parsed = urllib.parse.urlparse(self.path)
        qs = urllib.parse.parse_qs(parsed.query)
        if qs.get("token", [""])[0] == token:
            return True
        return False

    def _log_hit(self):
        parsed = urllib.parse.urlparse(self.path)
        print(f"[{now()}] HIT from {self.client_address[0]}:{self.client_address[1]} "
              f"{self.command} {parsed.path}?{parsed.query}".rstrip("?"))
        # You can print headers too if desired:
        # for k, v in self.headers.items():
        #     print(f"    {k}: {v}")

    def do_GET(self):
        self._log_hit()
        if not self._authorized():
            self.send_response(401)
            self.send_header("Content-Type", "text/plain; charset=utf-8")
            self.end_headers()
            self.wfile.write(b"Unauthorized (missing/invalid token)\n")
            return

        parsed = urllib.parse.urlparse(self.path)
        if parsed.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "text/plain; charset=utf-8")
            self.end_headers()
            self.wfile.write(b"ok\n")
            return

        if parsed.path == "/echo":
            qs = urllib.parse.parse_qs(parsed.query)
            payload = {
                "time": now(),
                "client": f"{self.client_address[0]}:{self.client_address[1]}",
                "method": self.command,
                "path": parsed.path,
                "query": qs,
                "headers": {k: v for k, v in self.headers.items()},
            }
            data = (str(payload) + "\n").encode("utf-8")
            self.send_response(200)
            self.send_header("Content-Type", "text/plain; charset=utf-8")
            self.end_headers()
            self.wfile.write(data)
            return

        # Default response
        msg = (
            "UPnP-exposed HTTP server is running.\n"
            "Try /health or /echo\n"
        ).encode("utf-8")
        self.send_response(200)
        self.send_header("Content-Type", "text/plain; charset=utf-8")
        self.end_headers()
        self.wfile.write(msg)

    def log_message(self, fmt, *args):
        # Silence BaseHTTPRequestHandler's default logging; we print our own.
        return


def pick_free_port(bind_host="0.0.0.0"):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((bind_host, 0))
    port = s.getsockname()[1]
    s.close()
    return port


def main():
    ap = argparse.ArgumentParser(description="Expose a local HTTP server via UPnP IGD port mapping.")
    ap.add_argument("--bind", default="0.0.0.0", help="Bind address for local server (default: 0.0.0.0)")
    ap.add_argument("--local-port", type=int, default=0, help="Local TCP port (0 = auto)")
    ap.add_argument("--external-port", type=int, default=0, help="External TCP port (0 = random high port)")
    ap.add_argument("--lease", type=int, default=0, help="Lease duration seconds (0 = indefinite if router allows)")
    ap.add_argument("--desc", default="python-upnp-bootstrap", help="Port mapping description")
    ap.add_argument("--token", default="", help="Require this token (or auto-generate if empty)")
    args = ap.parse_args()

    token = args.token.strip()
    if token == "":
        token = os.environ.get("BOOTSTRAP_TOKEN", "").strip()
    if token == "":
        # Generate a simple token
        token = "".join(random.choice("abcdefghijklmnopqrstuvwxyz0123456789") for _ in range(20))

    internal_ip = get_local_ip()
    local_port = args.local_port or pick_free_port(args.bind)

    print(f"[{now()}] Local IP: {internal_ip}")
    print(f"[{now()}] Starting HTTP server on {args.bind}:{local_port} (token required)")

    httpd = ThreadingHTTPServer((args.bind, local_port), Handler)
    httpd.token = token

    # UPnP discovery + mapping
    location = ssdp_discover(timeout=3.0)
    if not location:
        print(f"[{now()}] ERROR: Could not discover UPnP IGD (SSDP). Is UPnP enabled on your router?")
        print(f"[{now()}] Server is still running locally, but NOT reachable from the internet.")
        print(f"Local test:  http://127.0.0.1:{local_port}/health?token={token}")
        httpd.serve_forever()
        return

    control_url, service_type = find_igd_control_url(location)
    if not control_url:
        print(f"[{now()}] ERROR: Found device description but no WANIPConnection/WANPPPConnection control URL.")
        print(f"[{now()}] Server is still running locally, but NOT reachable from the internet.")
        print(f"Local test:  http://127.0.0.1:{local_port}/health?token={token}")
        httpd.serve_forever()
        return

    external_port = args.external_port
    if external_port == 0:
        external_port = random.randint(20000, 60000)

    mapped = False
    ext_ip = None

    def cleanup():
        nonlocal mapped
        if mapped:
            try:
                delete_port_mapping(control_url, service_type, external_port)
                print(f"[{now()}] Cleaned up port mapping {external_port}/TCP")
            except Exception as e:
                print(f"[{now()}] WARNING: Failed to delete port mapping: {e}")

    atexit.register(cleanup)

    try:
        # Try mapping; if it fails due to conflict, try a few ports
        for _ in range(8):
            try:
                add_port_mapping(
                    control_url, service_type,
                    external_port=external_port,
                    internal_ip=internal_ip,
                    internal_port=local_port,
                    desc=args.desc,
                    lease_seconds=args.lease
                )
                mapped = True
                break
            except Exception as e:
                external_port = random.randint(20000, 60000)

        if not mapped:
            raise RuntimeError("Unable to create UPnP port mapping after multiple attempts.")

        ext_ip = get_external_ip(control_url, service_type) or "UNKNOWN_PUBLIC_IP"
        print(f"[{now()}] UPnP mapping OK: {ext_ip}:{external_port} -> {internal_ip}:{local_port}")
        print(f"[{now()}] Public URL: http://{ext_ip}:{external_port}/health?token={token}")
        print(f"[{now()}] (or header: X-Auth-Token: {token})")

    except Exception as e:
        print(f"[{now()}] ERROR: UPnP setup failed: {e}")
        print(f"[{now()}] Server is still running locally, but NOT reachable from the internet.")
        print(f"Local test:  http://127.0.0.1:{local_port}/health?token={token}")

    # Run server
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print(f"\n[{now()}] Shutting down...")
    finally:
        httpd.server_close()
        # atexit cleanup will run


if __name__ == "__main__":
    main()
